#pragma once


#include "../../../Module/MemBuffer/CycleMemBuffer.h"
#include "../../../Module/CriticalSection/SynCriticalSection.h"

#include "DeviceModel/DevcieModel.h"
//#include "DeviceModel/DeviceModelDefine.h"

#include "PpPackageSendMngr.h"
#include "PpRecordMngr.h"
#include "PpDataInterface.h"

// CPpChnTestThread

class CPpChnTestThread : public CWinThread
{
	DECLARE_DYNCREATE(CPpChnTestThread)

protected:
	CPpChnTestThread();           // 动态创建所使用的受保护的构造函数
	virtual ~CPpChnTestThread();
	BOOL m_bHasPostWmquit;


public:
	void PostConnectDeviceMsg();
	BOOL IsConnecting();
	BOOL IsConnectSuccessful();
	void OnDeviceConnectFinish(BOOL bSucc);

	static CPpChnTestThread* CreateEngineThread(CDeviceCmmConfig *pDeviceCmmConfig)
	{
		CPpChnTestThread *pThread = (CPpChnTestThread*)AfxBeginThread(RUNTIME_CLASS(CPpChnTestThread), THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);
		pThread->m_pEngineData = pEngineData;
		pThread->Init(pEngineData->m_pDevcieModel, pEngineData->m_pTemplate);
		pEngineData->m_pDeviceCmmChannelRef = pThread->m_pDeviceCmmChannel;
		pThread->ResumeThread();
		return pThread;
	}

	void Init(CDevcieModel *pDevcieModel, CPpTemplate *pTemplate)
	{
		ASSERT (pTemplate != NULL);
		ASSERT (pDevcieModel != NULL);

		m_pDevcieModel = pDevcieModel;
		m_pDevice = m_pDevcieModel->m_pDevice;
		m_pDeviceCmmConfig = m_pDevcieModel->m_pDeviceCmmConfig;
		m_pTemplate = pTemplate;  
		m_pTemplate->SetDevice(m_pDevice);
	}

	void SetDeleteEngineDataInExit(BOOL b)	{	m_bDeleteEngineDataInExit = b;	}
//////////////////////////////////////////////////////////////////////////
//引擎数据定义
public:
	
	//CCycleMemBuffer m_oReceiveBuffer;   //接收缓冲区管理对象

	//模型/模板
	CDvmDevice *m_pDevice;         //设备点表数据管理对象
	CDeviceCmmConfig *m_pDeviceCmmConfig;  //设备通讯配置对象
	CDeviceCmmChannel *m_pDeviceCmmChannel;    //关联的设备通讯对象
	
	CPpPackageSendMngr *m_pPkgSendMngr;  //报文帧发送管理对象
			
	//接受帧对象管理:过程执行线程从此获取PackageDetail对象进行跳转的判断
	CExBaseList m_listReceivePackage;             //解析出来的帧对象

private:
	BOOL m_bDeleteEngineDataInExit;

//////////////////////////////////////////////////////////////////////////
//引擎方法定义
public:
	void RunProcedure(const CString &strProcedureID, CExBaseList *pInterface); //执行过程
	void KillProcedure(const CString &strProcedureID, CExBaseList *pInterface = NULL); //执行过程
	void AddReceivePackageDetail(CPpPackageDetail *pPkg);//添加解析完成的帧对象到临时列表
	void ViewProcedure();
		
	//模板 加载/卸载
	void LoadTemplate(const CString &strTemplageFile);
	void UnLoad();
		
	//设备连接、断开管理
	BOOL ConnectDevice();
	BOOL CmmChannelConfig();
	BOOL DisConnectDevice();

	//数据接受,关联的m_pChannel对象收到数据后,通知EngineThread对象
	void OnReceived(CCmmRcvSndTime *pCmmTime);
	
	// 缓冲区处理
	void CreateParseBufferPos(PACKAGEBUFFERPOS &oBufPos);
	void CreateParseBufferPos(CYCLEMEMBUFFERPOS &oBufPos, long nBeginPos, long nEndPos);
	void LogErrorParse(long nBeginPos, long nLength);
	
	//获取通讯通道
	CCmmChannel* GetCmmChannel(const CString &strCmmChannelID);
	CCmmChannel* GetCmmChannel(CPpNode *pNode);

	//添加发送报文对象
	CPpPackageSend* AddPackageSend(CPpProcedureRun *pPpProcedureRun);

	// 设备通讯配置数据管理
	void CopyDeviceCmmConfig(CDeviceCmmConfig *pDes, CDeviceCmmConfig* pSrc);
	CExBaseObject* FindByClassID(UINT nClassID, CExBaseList* pList);

	void SetCurrPkgLen(long nLen)   {    m_nCurrPkgLen = nLen;   }
	BOOL GetDeviceAttribute(const CString &strAttrTag, CString &strAttrValue);
	BOOL SetDeviceAttribute(const CString &strAttrTag, const CString &strAttrValue);

public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();

	void ExitEngineThread() ;
	void ExitRunProduceThread();
	BOOL IsThreadExitExtern();
	BOOL IsRunProduceThreadExit();

	//监视报文
	void LogProtocol(CExBaseObject *pDevice, LPVOID pPara, CYCLEMEMBUFFERPOS &oBufPos, BOOL bRecv=TRUE, const CString &strTime=_T(""));
	void LogProtocol(CYCLEMEMBUFFERPOS &oBufPos, CString &strMsg);
	void RecordSendPackage();

	void OnProcedureExit(CPpProcedureRun *pPpProcedureRun);
	void OnProcedureStart(CPpProcedureRun *pPpProcedureRun);

private:
	BOOL IsThreadExit();
	long m_nThreadExitState;

private:
	//发送接收处理线程
	static UINT PkgSendReceiveThread(LPVOID pParam);

	//////////////////////////////////////////////////////////////////////////
	//规约过程执行相关

	//过程执行线程从此取得过程加入到执行过程列表
	CExBaseList m_listProcedureToRun;	             //过程临时列表,将要执行的过程列表
	CExBaseList m_listRunProcedure;	                 //执行的过程列表
	CAutoCriticSection m_oPrcdrTmpCriticSection;  //m_listProcedureTemp访问的互斥量

	//Engine Thread相关的处理
	CWinThread *m_pProcedureRunThread;
	BOOL m_bExitEngineThread;

	//过程处理线程:死循环，不断遍历
	static UINT ProcedureRunThread(LPVOID pParam);
	CPpProcedureRun* FindRunningProcedure(const CString &strProcedureID);

	void InitPackageTime(CPpPackageDetail *pPkg, long nBeginPos);
	void AddTempProcedureToRun();

	void LogAllProcedure();
	void KillProcedure();

protected:
	DECLARE_MESSAGE_MAP()
	afx_msg void AFX_MSG_CALL OnChannelReceive(WPARAM wParam, LPARAM lParam); 
	afx_msg void AFX_MSG_CALL OnConnectDevice(WPARAM wParam, LPARAM lParam);
	afx_msg void AFX_MSG_CALL OnDisConnectDevice(WPARAM wParam, LPARAM lParam);
	afx_msg void AFX_MSG_CALL OnExitEngineThread(WPARAM wParam, LPARAM lParam);
	afx_msg void AFX_MSG_CALL OnDeleteAllRecordPackage(WPARAM wParam, LPARAM lParam);
};


